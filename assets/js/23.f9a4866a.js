(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{318:function(t,e,a){"use strict";a.r(e);var n=a(39),r=Object(n.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"javascript-数据类型与类型判断详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript-数据类型与类型判断详解","aria-hidden":"true"}},[t._v("#")]),t._v(" JavaScript 数据类型与类型判断详解")]),t._v(" "),a("h2",{attrs:{id:"一、javascript-数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、javascript-数据类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、JavaScript 数据类型")]),t._v(" "),a("p",[t._v("JavaScript 数据类型有两种，分别是基本数据类型和引用数据类型。")]),t._v(" "),a("ul",[a("li",[t._v("基本数据类型"),a("strong",[t._v("NumberStringBooleanUndefinedNullSymbol")]),t._v(" (ES6 新增，表示独一无二的值)")]),t._v(" "),a("li",[t._v("引用数据类型"),a("strong",[t._v("ObjectFunctionArray")])])]),t._v(" "),a("p",[t._v("我们来详细了解一下这两种数据类型的特点")]),t._v(" "),a("h2",{attrs:{id:"_1-基本数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-基本数据类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.基本数据类型")]),t._v(" "),a("h3",{attrs:{id:"值不可变"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#值不可变","aria-hidden":"true"}},[t._v("#")]),t._v(" 值不可变")]),t._v(" "),a("p",[t._v("基本类型的值是 "),a("strong",[t._v("不可变")]),t._v(" 的")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var name = 'javascript';\nname.toUpperCase(); //  'JAVASCRIPT'\nconsole.log(name); //  'javascript'\n")])])]),a("p",[t._v("但是我们不是经常有 ++a 这种操作吗？比如")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let a = 1\nconsole.log(++a) // '2'\n")])])]),a("p",[t._v("其实这个时候并不是 a 指向的 1 直接加了 1，而是 新建了一个 1+1 = 2 的值，再将 a 指向这个新建出来的 2，原来的那个 1 并没有发生改变，留由垃圾回收机制处理。也就是说不是 a 指向的值发生了改变，而是 a 变量指针指向了一个新的值，这和「基本类型的值是不可变的」这句话并不矛盾。")]),t._v(" "),a("h3",{attrs:{id:"数据存放在栈区"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据存放在栈区","aria-hidden":"true"}},[t._v("#")]),t._v(" 数据存放在栈区")]),t._v(" "),a("p",[t._v("原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储。")]),t._v(" "),a("h2",{attrs:{id:"_2-引用数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-引用数据类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.引用数据类型")]),t._v(" "),a("h3",{attrs:{id:"值是可变的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#值是可变的","aria-hidden":"true"}},[t._v("#")]),t._v(" 值是可变的")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let a = { age : 20 }；\na.age = 21；\nconsole.log(a.age)    //21\n")])])]),a("h3",{attrs:{id:"同时保存在栈内存和堆内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同时保存在栈内存和堆内存","aria-hidden":"true"}},[t._v("#")]),t._v(" 同时保存在栈内存和堆内存")]),t._v(" "),a("p",[t._v("引用数据类型占据空间大，大小不固定，储存在堆内存，但是指向该引用数据类型的变量指针「a」是储存在栈内存中。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。")]),t._v(" "),a("h2",{attrs:{id:"二、数据的赋值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、数据的赋值","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、数据的赋值")]),t._v(" "),a("p",[t._v("基本数据类型的赋值为复制了一个新的值，对新变量的修改不会影响原变量")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let a = 1;\nlet b = a;\nb++\nconsole.log(a)   // 1\nconsole.log(b)   // 2\n")])])]),a("p",[t._v("在内存中的变化如图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://p3.pstatp.com/large/pgc-image/2ef7e91a6cc845bd9244b08f15e3de8c",alt:"JavaScript 数据类型与类型判断详解"}})]),t._v(" "),a("p",[t._v("但是引用数据类型就不一样，因为引用数据内型占用空间大，所以赋值操作是将新变量指针指向了原对象，修改其一都会影响到另一个。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("let a={id=1234}\nlet b=a\nb.id=1222\nconsole.log(a.id) // 1222\nconsole.log(b.id) // 1222\n")])])]),a("p",[t._v("在内存中的变化如图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://p1.pstatp.com/large/pgc-image/875cb3c022f14d28bd8b6dbf54270762",alt:"JavaScript 数据类型与类型判断详解"}})]),t._v(" "),a("p",[t._v("关于引用对象的拷贝又分为深拷贝和浅拷贝，限于篇幅就留给下篇文章了")]),t._v(" "),a("h2",{attrs:{id:"三、检验数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、检验数据类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、检验数据类型")]),t._v(" "),a("h2",{attrs:{id:"typeof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typeof","aria-hidden":"true"}},[t._v("#")]),t._v(" typeof")]),t._v(" "),a("p",[t._v("这应该初学者首次接触的类型判断方法了，它返回一个表示数据类型的字符串，返回结果包括：")]),t._v(" "),a("ul",[a("li",[t._v("number")]),t._v(" "),a("li",[t._v("boolean")]),t._v(" "),a("li",[t._v("string")]),t._v(" "),a("li",[t._v("symbol")]),t._v(" "),a("li",[t._v("object")]),t._v(" "),a("li",[t._v("undefined")]),t._v(" "),a("li",[t._v("function")])]),t._v(" "),a("p",[t._v("但是不能判断 array 和 null")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("typeof Symbol();\n// symbol  正确\ntypeof '';\n// string 正确\ntypeof 1;\n// number正确\ntypeof true;\n//boolean 正确\ntypeof undefined;\n//undefined 正确\ntypeof new Function();\n// function 正确\ntypeof null;\n//object 无效\ntypeof [] ;\n//object 无效\ntypeof new Date();\n//object 无效\ntypeof new RegExp();\n//object 无效\n")])])]),a("h4",{attrs:{id:"typeof-缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#typeof-缺点","aria-hidden":"true"}},[t._v("#")]),t._v(" typeof 缺点")]),t._v(" "),a("p",[t._v("可以看到 Date 和 RegExp 对象都只是被是被成了 object 对象，也就是说除 function 以外的对象都会被识别成 object ，这样显然是不合理的，这时就需要 instanceof 来进行判断。")]),t._v(" "),a("h2",{attrs:{id:"instanceof"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#instanceof","aria-hidden":"true"}},[t._v("#")]),t._v(" instanceof")]),t._v(" "),a("p",[t._v("instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 简单来说就是 instanceof 是用来判断 A 是否为 B 的实例，表达式为")]),t._v(" "),a("p",[a("strong",[t._v("A (object) instanceof B (constructor)")])]),t._v(" "),a("p",[t._v("如果 A 是 B 的实例，则返回 true,否则返回 false。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// 定义构造函数\nfunction C(){}\nfunction D(){}\n\nvar o = new C();\n\n\no instanceof C; // true，因为 Object.getPrototypeOf(o) === C.prototype\n\n\no instanceof D; // false，因为 D.prototype 不在 o 的原型链上\n\no instanceof Object; // true，因为 Object.prototype.isPrototypeOf(o) 返回 true\n\nC.prototype instanceof Object // true，同上\n\nC.prototype = {};\n\nvar o2 = new C();\n\no2 instanceof C; // true\n\no instanceof C; // false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.\n\nD.prototype = new C(); // 继承\nvar o3 = new D();\no3 instanceof D; // true\no3 instanceof C; // true 因为 C.prototype 现在在 o3 的原型链上\n")])])]),a("p",[t._v("现在就可以判断不同类别的对象了")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("[] instanceof Array; //true\n{} instanceof Object;//true\nnew Date() instanceof Date;//true\nnew RegExp() instanceof RegExp//true\n")])])]),a("h4",{attrs:{id:"instanceof-的缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#instanceof-的缺点","aria-hidden":"true"}},[t._v("#")]),t._v(" instanceof 的缺点")]),t._v(" "),a("h4",{attrs:{id:"_1-是否处于原型链上的判断方法不严谨"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-是否处于原型链上的判断方法不严谨","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.是否处于原型链上的判断方法不严谨")]),t._v(" "),a("p",[t._v("instanceof 方法判断的是是否处于原型链上，而不是是不是处于原型链最后一位，所以会出现下面这种情况：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var arr = [1, 2, 3];\nconsole.log(arr instanceof Array) // true\nconsole.log(arr instanceof Object);  // true\nfunction fn(){}\nconsole.log(fn instanceof Function)// true\nconsole.log(fn instanceof Object)// true\n")])])]),a("p",[t._v("因为所有原型链的尽头都是 object，所以就造成了这种状况。当你自定义了一个类 A，并且继承了一个原生类 B，这个时候 "),a("strong",[t._v("检测结果未必准确")]),t._v(" ：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("A instanceof A // true\nA instanceof B // true\nA instanceof Object true\n")])])]),a("h4",{attrs:{id:"_2-无法判断字面量方式创建的基本数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-无法判断字面量方式创建的基本数据类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.无法判断字面量方式创建的基本数据类型")]),t._v(" "),a("p",[t._v("对于基本数据类型来说， "),a("strong",[t._v("字面量方式")]),t._v(" 创建出来的结果和 "),a("strong",[t._v("实例方式创建")]),t._v(" 的是 "),a("strong",[t._v("有一定区别")]),t._v(" 的")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("console.log(1 instanceof Number)//false\nconsole.log(new Number(1) instanceof Number)//true\n")])])]),a("p",[t._v("从严格意义上来讲， "),a("strong",[t._v("只有实例创建出来的结果才是标准的对象数据类型值")]),t._v(" ，也是标准的 Number 这个类的一个实例；对于字面量方式创建出来的结果是基本的数据类型值，不是严谨的实例，但是由于 JS 的松散特点，导致了可以使用 Number.prototype 上提供的方法。")]),t._v(" "),a("h4",{attrs:{id:"_3-无法检测-null-和-undefined"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-无法检测-null-和-undefined","aria-hidden":"true"}},[t._v("#")]),t._v(" 3. 无法检测 null 和 undefined")]),t._v(" "),a("p",[t._v("对于特殊的数据类型 null 和 undefined，他们的所属类是 Null 和 Undefined，但是浏览器把这两个类保护起来了，不允许我们在外面访问使用。")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://p1.pstatp.com/large/pgc-image/7fc48414222d42e29f80a6ab751705f7",alt:"JavaScript 数据类型与类型判断详解"}})]),t._v(" "),a("h2",{attrs:{id:"constructor"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constructor","aria-hidden":"true"}},[t._v("#")]),t._v(" constructor")]),t._v(" "),a("p",[t._v("constructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，还可以处理基本数据类型的检测。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var aa=[1,2];\nconsole.log(aa.constructor===Array);//true\nconsole.log(aa.constructor===RegExp);//false\nconsole.log((1).constructor===Number);//true\nvar reg=/^$/;\nconsole.log(reg.constructor===RegExp);//true\nconsole.log(reg.constructor===Object);//false\n")])])]),a("h4",{attrs:{id:"constructor-的缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#constructor-的缺点","aria-hidden":"true"}},[t._v("#")]),t._v(" constructor 的缺点")]),t._v(" "),a("h4",{attrs:{id:"_1-无法检测-null-和-undefined"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-无法检测-null-和-undefined","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.无法检测 null 和 undefined")]),t._v(" "),a("p",[t._v("null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。")]),t._v(" "),a("h4",{attrs:{id:"_2-不稳定"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-不稳定","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.不稳定")]),t._v(" "),a("p",[t._v("函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写，在重写的过程中很有可能出现把之前的 constructor 给覆盖了，这样检测出来的结果就是不准确的，由此可知 instanceof 同样也存在这个问题。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function Fn(){}\nFn.prototype = new Array()\nvar f = new Fn\nconsole.log(f.constructor)//Array\n")])])]),a("h2",{attrs:{id:"object-prototype-tostring-call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-prototype-tostring-call","aria-hidden":"true"}},[t._v("#")]),t._v(" Object.prototype.toString.call()")]),t._v(" "),a("p",[t._v("这就是大名鼎鼎的全能方法，最准确最常用，据 MDN 描述")]),t._v(" "),a("p",[t._v('每个对象都有一个 toString() 方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString() 方法被每个 Object 对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 "[object type]"，其中 type 是对象的类型。')]),t._v(" "),a("p",[t._v('在 Number、String，Boolean，Array，RegExp、Date、Function 等对象上 toString() 方法都是被重写过了的，会按照一定的规则返回字符串。但是在 object 对象上，这个方式是返回当前方法执行的主体（方法中的 this）所属类的详细信息即"[object Object]",其中第一个 object 代表当前实例是对象数据类型的(这个是固定的 onject)，第二个 Object 代表的是 this 所属的类型。')]),t._v(" "),a("p",[t._v("为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数，称为 thisArg。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Object.prototype.toString.call('') ;   // [object String]\nObject.prototype.toString.call(1) ;    // [object Number]\nObject.prototype.toString.call(true) ; // [object Boolean]\nObject.prototype.toString.call(undefined) ; // [object Undefined]\nObject.prototype.toString.call(null) ; // [object Null]\nObject.prototype.toString.call(new Function()) ; // [object Function]\nObject.prototype.toString.call(new Date()) ; // [object Date]\nObject.prototype.toString.call([]) ; // [object Array]\nObject.prototype.toString.call(new RegExp()) ; // [object RegExp]\nObject.prototype.toString.call(new Error()) ; // [object Error]\nObject.prototype.toString.call(document) ; // [object HTMLDocument]\nObject.prototype.toString.call(window) ; //[object global] window是全局对象global的引用\n")])])]),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结","aria-hidden":"true"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("判断方法")]),t._v(" "),a("th",[t._v("缺点")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("typeof")]),t._v(" "),a("td",[t._v("不能判断 null 和区分 array/Date/RegExp 等")])]),t._v(" "),a("tr",[a("td",[t._v("instanceof")]),t._v(" "),a("td",[t._v("无法检测 null 和 undefined,未必准确，无法判断字面量方式创建的基本数据类型")])]),t._v(" "),a("tr",[a("td",[t._v("constructor")]),t._v(" "),a("td",[t._v("无法检测 null 和 undefined，未必准确")])]),t._v(" "),a("tr",[a("td",[t._v("Object.prototype.toString.call()")]),t._v(" "),a("td",[t._v("无")])])])]),t._v(" "),a("Valine")],1)},[],!1,null,null,null);e.default=r.exports}}]);