(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{310:function(a,t,s){"use strict";s.r(t);var n=s(39),e=Object(n.a)({},function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"【译】async-await和promise的不为人知的秘密"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#【译】async-await和promise的不为人知的秘密","aria-hidden":"true"}},[a._v("#")]),a._v(" 【译】Async/await和Promise的不为人知的秘密")]),a._v(" "),s("p",[a._v("大家知道，Async/await是generator和Promise的语法糖，但仅仅是语法糖吗？ 它们两个的性能有没有区别呢， 又或者 promise.then()和await 同为微任务，但是它们的执行顺序是怎样的呢？")]),a._v(" "),s("h3",{attrs:{id:"首先先介绍async-await是如何优化javascript引擎的堆栈处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#首先先介绍async-await是如何优化javascript引擎的堆栈处理","aria-hidden":"true"}},[a._v("#")]),a._v(" 首先先介绍Async/await是如何优化JavaScript引擎的堆栈处理")]),a._v(" "),s("p",[a._v("是的，你没有看错，通过标题你就知道了，async/await相比较Promise来说，是优化了堆栈处理的，也就是说，在这一点上，Async/await是比Promise性能好的")]),a._v(" "),s("p",[a._v("与直接使用Promise相比，使用Async/Await不仅可以提高代码的可读性，同时也可以优化JavaScript引擎的执行方式")]),a._v(" "),s("p",[s("strong",[a._v("说完 ‘是什么’，接下来我们讨论一下 ‘为什么’")])]),a._v(" "),s("p",[a._v("Async/Await与Promise最大区别在于：await b()会暂停所在的async函数的执行；而Promise.then(b)将b函数加入回调链中之后，会继续执行当前函数。对于堆栈来说，这个不同点非常关键。")]),a._v(" "),s("p",[a._v("当一个Promise链抛出一个未处理的错误时，无论我们使用await b()还是Promise.then(b)，JavaScript引擎都需要打印错误信息及其堆栈。对于JavaScript引擎来说，两者获取堆栈的方式是不同的。")]),a._v(" "),s("h3",{attrs:{id:"promise-then"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-then","aria-hidden":"true"}},[a._v("#")]),a._v(" Promise.then()")]),a._v(" "),s("p",[a._v("观察下面代码, 假设b()返回一个promise")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("then")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n复制代码\n")])])]),s("p",[a._v("当调用a()函数时，这些事情同步发生，b()函数产生一个promise对象，调用then方法，Promise会在将来的某个时刻resolve，也就是把then里的回调函数添加到回调链。(如果这一块不太明白，可以仔细学习promise，或者读一读promise源码并尝试写一写，相信你更通透)，这样，a()函数就执行完了，在这个过程中，a()函数并不会暂停，因此在异步函数resolve的时候，a()的作用域已经不存在了，那要如何生成包含a()的堆栈信息呢？ 为了解决这个问题，JavaScripts引擎要做一些额外的工作；它会及时记录并保存堆栈信息。对于V8引擎来说，这些堆栈信息随着Promise在Promise链中传递，这样c()函数在需要的时候也能获取堆栈信息。但是这无疑造成了额外的开销，会降低性能；保存堆栈信息会占用额外的内存。")]),a._v(" "),s("h3",{attrs:{id:"await"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#await","aria-hidden":"true"}},[a._v("#")]),a._v(" Await")]),a._v(" "),s("p",[a._v("我们可以用Async/await来实现一下")]),a._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[a._v("a")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=>")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("await")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("b")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("c")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n复制代码\n")])])]),s("p",[a._v("使用await的时候，无需存储堆栈信息，因为存储b()到a()的指针的足够了。当b()函数执行的时候，a()函数被暂停了，因此a()函数的作用域还在内存可以访问。如果b()抛出一个错误，堆栈通过指针迅速生成。如果c()函数抛出一个错误，堆栈信息也可以像同步函数一样生成，因为c()是在a()中执行的。不论是b()还是c()，我们都不需要去存储堆栈信息，因为堆栈信息可以在需要的时候立即生成。而存储指针，显然比存储堆栈更加节省内存")]),a._v(" "),s("h3",{attrs:{id:"结论"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#结论","aria-hidden":"true"}},[a._v("#")]),a._v(" 结论")]),a._v(" "),s("p",[a._v("很多ECMAScript语法特性看起来都只是些语法糖，其实并非如此，至少Async/await绝不仅仅是语法糖 为了让JavaScript引擎处理堆栈的方式性能更高，请尽量使用Async/await，而不是直接使用Promise")]),a._v(" "),s("ul",[s("li",[a._v("原文: "),s("a",{attrs:{href:"https://mathiasbynens.be/notes/async-stack-traces",target:"_blank",rel:"noopener noreferrer"}},[a._v("mathiasbynens.be/notes/async…"),s("OutboundLink")],1)]),a._v(" "),s("li",[a._v("作者: Mathias Bynens : Google V8引擎开发者")]),a._v(" "),s("li",[a._v("意译而非直译")])])])},[],!1,null,null,null);t.default=e.exports}}]);