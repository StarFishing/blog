<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>谈论分支策略和发布管理 | XiaoXin</title>
    <meta name="description" content="Everything Is Esay">
    <link rel="shortcut icon" href="/blog/favicon.ico">
  <meta name="referrer" content="no-referrer">
    
    <link rel="preload" href="/blog/assets/css/0.styles.c98d2fd1.css" as="style"><link rel="preload" href="/blog/assets/js/app.2ae5fea5.js" as="script"><link rel="preload" href="/blog/assets/js/2.6a053b7f.js" as="script"><link rel="preload" href="/blog/assets/js/65.fea30c40.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.24a80492.js"><link rel="prefetch" href="/blog/assets/js/11.15dd0e81.js"><link rel="prefetch" href="/blog/assets/js/12.80be22dc.js"><link rel="prefetch" href="/blog/assets/js/13.8f3eea23.js"><link rel="prefetch" href="/blog/assets/js/14.4a737e05.js"><link rel="prefetch" href="/blog/assets/js/15.eb07cf8a.js"><link rel="prefetch" href="/blog/assets/js/16.36d73765.js"><link rel="prefetch" href="/blog/assets/js/17.17bc1d4d.js"><link rel="prefetch" href="/blog/assets/js/18.dc604255.js"><link rel="prefetch" href="/blog/assets/js/19.dba65164.js"><link rel="prefetch" href="/blog/assets/js/20.b1e13490.js"><link rel="prefetch" href="/blog/assets/js/21.6661e953.js"><link rel="prefetch" href="/blog/assets/js/22.b46aff83.js"><link rel="prefetch" href="/blog/assets/js/23.f9a4866a.js"><link rel="prefetch" href="/blog/assets/js/24.abc1ee8e.js"><link rel="prefetch" href="/blog/assets/js/25.5c6de7f7.js"><link rel="prefetch" href="/blog/assets/js/26.f0a361d6.js"><link rel="prefetch" href="/blog/assets/js/27.170936fa.js"><link rel="prefetch" href="/blog/assets/js/28.7899db47.js"><link rel="prefetch" href="/blog/assets/js/29.a7194b2b.js"><link rel="prefetch" href="/blog/assets/js/3.ebad0fee.js"><link rel="prefetch" href="/blog/assets/js/30.b2dee036.js"><link rel="prefetch" href="/blog/assets/js/31.c1603b7d.js"><link rel="prefetch" href="/blog/assets/js/32.9b4872ae.js"><link rel="prefetch" href="/blog/assets/js/33.0c4a6762.js"><link rel="prefetch" href="/blog/assets/js/34.216a6e8c.js"><link rel="prefetch" href="/blog/assets/js/35.c4da4fba.js"><link rel="prefetch" href="/blog/assets/js/36.4004ae2a.js"><link rel="prefetch" href="/blog/assets/js/37.970402d3.js"><link rel="prefetch" href="/blog/assets/js/38.5940f18d.js"><link rel="prefetch" href="/blog/assets/js/39.a9f7a9d7.js"><link rel="prefetch" href="/blog/assets/js/4.2282b1d2.js"><link rel="prefetch" href="/blog/assets/js/40.cab95d99.js"><link rel="prefetch" href="/blog/assets/js/41.c43504e7.js"><link rel="prefetch" href="/blog/assets/js/42.fea032c4.js"><link rel="prefetch" href="/blog/assets/js/43.d981b84c.js"><link rel="prefetch" href="/blog/assets/js/44.e469946c.js"><link rel="prefetch" href="/blog/assets/js/45.498af734.js"><link rel="prefetch" href="/blog/assets/js/46.5c5381de.js"><link rel="prefetch" href="/blog/assets/js/47.ade54cb1.js"><link rel="prefetch" href="/blog/assets/js/48.543817c4.js"><link rel="prefetch" href="/blog/assets/js/49.170032f2.js"><link rel="prefetch" href="/blog/assets/js/5.bbd49a80.js"><link rel="prefetch" href="/blog/assets/js/50.fdcebebc.js"><link rel="prefetch" href="/blog/assets/js/51.4688ae90.js"><link rel="prefetch" href="/blog/assets/js/52.2f859e2a.js"><link rel="prefetch" href="/blog/assets/js/53.46f20752.js"><link rel="prefetch" href="/blog/assets/js/54.8c4e2bde.js"><link rel="prefetch" href="/blog/assets/js/55.966bf42b.js"><link rel="prefetch" href="/blog/assets/js/56.93296c52.js"><link rel="prefetch" href="/blog/assets/js/57.c0e84a0a.js"><link rel="prefetch" href="/blog/assets/js/58.9c4fac4f.js"><link rel="prefetch" href="/blog/assets/js/59.18ed476c.js"><link rel="prefetch" href="/blog/assets/js/6.3b02335f.js"><link rel="prefetch" href="/blog/assets/js/60.e3ca94f3.js"><link rel="prefetch" href="/blog/assets/js/61.d40e0732.js"><link rel="prefetch" href="/blog/assets/js/62.952d91f1.js"><link rel="prefetch" href="/blog/assets/js/63.03715906.js"><link rel="prefetch" href="/blog/assets/js/64.6dce55d6.js"><link rel="prefetch" href="/blog/assets/js/66.21bee15e.js"><link rel="prefetch" href="/blog/assets/js/7.64ef9703.js"><link rel="prefetch" href="/blog/assets/js/8.c33961b5.js"><link rel="prefetch" href="/blog/assets/js/9.61bba5ba.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.c98d2fd1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">XiaoXin</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/HTML+CSS/" class="nav-link">HTML+CSS</a></div><div class="nav-item"><a href="/blog/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/blog/React/" class="nav-link">React</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/Vue/VuePress/" class="nav-link">VuePress</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/electron/" class="nav-link">electron</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/vue官方文档解读/" class="nav-link">vue官方文档解读</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/关于双向绑定的探索/" class="nav-link">关于双向绑定的探索</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/源码学习/" class="nav-link">源码学习</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/问题记录/" class="nav-link">问题记录</a></li></ul></div></div><div class="nav-item"><a href="/blog/命名规范/" class="nav-link">命名规范</a></div><div class="nav-item"><a href="/blog/图床/" class="nav-link">图床</a></div><div class="nav-item"><a href="/blog/大前端/" class="nav-link">大前端</a></div> <a href="https://github.com/starfishing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/HTML+CSS/" class="nav-link">HTML+CSS</a></div><div class="nav-item"><a href="/blog/JavaScript/" class="nav-link">JavaScript</a></div><div class="nav-item"><a href="/blog/React/" class="nav-link">React</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">Vue</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/Vue/VuePress/" class="nav-link">VuePress</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/electron/" class="nav-link">electron</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/vue官方文档解读/" class="nav-link">vue官方文档解读</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/关于双向绑定的探索/" class="nav-link">关于双向绑定的探索</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/源码学习/" class="nav-link">源码学习</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/问题记录/" class="nav-link">问题记录</a></li></ul></div></div><div class="nav-item"><a href="/blog/命名规范/" class="nav-link">命名规范</a></div><div class="nav-item"><a href="/blog/图床/" class="nav-link">图床</a></div><div class="nav-item"><a href="/blog/大前端/" class="nav-link">大前端</a></div> <a href="https://github.com/starfishing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/blog/%E5%A4%A7%E5%89%8D%E7%AB%AF/" class="sidebar-link">前言</a></li><li><a href="/blog/大前端/关于架构.html" class="sidebar-link">前端架构</a></li><li><a href="/blog/大前端/谈论分支策略和发布管理.html" class="active sidebar-link">谈论分支策略和发布管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/大前端/谈论分支策略和发布管理.html#为什么是git？" class="sidebar-link">为什么是git？</a></li><li class="sidebar-sub-header"><a href="/blog/大前端/谈论分支策略和发布管理.html#分散但集中化" class="sidebar-link">分散但集中化</a></li><li class="sidebar-sub-header"><a href="/blog/大前端/谈论分支策略和发布管理.html#主要分支" class="sidebar-link">主要分支</a></li><li class="sidebar-sub-header"><a href="/blog/大前端/谈论分支策略和发布管理.html#支持分支" class="sidebar-link">支持分支</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/大前端/谈论分支策略和发布管理.html#功能分支" class="sidebar-link">功能分支</a></li><li class="sidebar-sub-header"><a href="/blog/大前端/谈论分支策略和发布管理.html#发布分支" class="sidebar-link">发布分支</a></li><li class="sidebar-sub-header"><a href="/blog/大前端/谈论分支策略和发布管理.html#修补程序分支" class="sidebar-link">修补程序分支</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/大前端/谈论分支策略和发布管理.html#总结" class="sidebar-link">总结</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="谈论分支策略和发布管理"><a href="#谈论分支策略和发布管理" aria-hidden="true" class="header-anchor">#</a> 谈论分支策略和发布管理</h1> <p><img src="https://nvie.com/img/git-model@2x.png" alt="img"></p> <h2 id="为什么是git？"><a href="#为什么是git？" aria-hidden="true" class="header-anchor">#</a> 为什么是git？</h2> <p>有关Git与集中式源代码控制系统相比的优缺点的详尽讨论，请参见 <a href="http://git.or.cz/gitwiki/GitSvnComparsion" target="_blank" rel="noopener noreferrer">Web<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。那里发生了许多火焰大战。作为开发人员，我比今天其他所有工具都更喜欢Git。Git确实改变了开发人员对合并和分支的看法。在我来自经典的CVS / Subversion的世界中，合并/分支一直被认为有点吓人（“当心合并冲突，它们会咬你！”），而您却偶尔会做一次。</p> <p>但是使用Git，这些操作非常便宜且简单，实际上，它们被视为<em>日常</em>工作流程的核心部分之一。例如，在CVS / Subversion <a href="http://svnbook.red-bean.com/" target="_blank" rel="noopener noreferrer">书籍中<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，分支和合并首先在后面的章节中（针对高级用户）进行讨论，而在 <a href="http://book.git-scm.com/" target="_blank" rel="noopener noreferrer">每本<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="http://pragprog.com/titles/tsgit/pragmatic-version-control-using-git" target="_blank" rel="noopener noreferrer">Git <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><a href="http://github.com/progit/progit" target="_blank" rel="noopener noreferrer">书籍中<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它都已经在第3章（基础知识）中进行了讨论。</p> <p>由于其简单性和重复性，分支和合并不再是令人害怕的事情。应该使用版本控制工具来帮助分支/合并。</p> <p>足够了解这些工具，让我们进入开发模型。我将在此处介绍的模型本质上不过是每个团队成员必须遵循的一组程序才能进入托管软件开发过程。</p> <h2 id="分散但集中化"><a href="#分散但集中化" aria-hidden="true" class="header-anchor">#</a> 分散但集中化</h2> <p>我们使用的存储库设置与该分支模型一起很好地使用，它是一个中央“真实”存储库。请注意，此回购协议仅<em>被视为</em> 中央回购协议 （由于Git是DVCS，因此在技术层面上没有中央回购协议）。我们将此仓库称为<code>origin</code>，因为所有Git用户都熟悉该名称。</p> <p><img src="https://nvie.com/img/centr-decentr@2x.png" alt="img"></p> <p>每个开发人员都拉起并推到原点。但是，除了集中的推拉关系之外，每个开发人员还可以从其他同伴那里拉出变更以组成子团队。例如，在<code>origin</code>过早地将进行中的工作之前，与两个或多个开发人员一起使用一项重大的新功能可能很有用 。在上图中，有Alice和Bob，Alice和David以及Clair和David的子团队。</p> <p>从技术上讲，这仅意味着Alice定义了一个Git远程服务器，名为<code>bob</code>，指向Bob的存储库，反之亦然。</p> <h2 id="主要分支"><a href="#主要分支" aria-hidden="true" class="header-anchor">#</a> 主要分支</h2> <p><img src="https://nvie.com/img/main-branches@2x.png" alt="img"></p> <p>从根本上说，开发模型的灵感来自那里的现有模型。中央存储库包含两个主要分支，生命周期无限：</p> <ul><li><code>master</code></li> <li><code>develop</code></li></ul> <p>每个Git用户都应该熟悉<code>master</code>at 的分支<code>origin</code>。与<code>master</code>分支平行，存在另一个分支，称为<code>develop</code>。</p> <p>我们认为<code>origin/master</code>它是源代码<code>HEAD</code>始终反映<em>生产就绪</em>状态的主要分支 。</p> <p>我们认为<code>origin/develop</code>这是主要分支，在该分支中的源代码 <code>HEAD</code>始终反映状态以及下一版本的最新交付开发更改。有人将其称为“整合分支”。这是构建任何夜间自动构建的地方。</p> <p>当<code>develop</code>分支中的源代码达到稳定点并准备发布时，所有更改都应以<code>master</code> 某种方式合并回去，然后用发布号进行标记。如何进一步详细地进行讨论。</p> <p>因此，每次将更改合并回时<code>master</code>，<em>根据定义</em>，这是一个新的生产版本。我们通常对此非常严格，因此从理论上讲，每次提交时，我们都可以使用Git钩子脚本自动将软件构建和推出到生产服务器 <code>master</code>。</p> <h2 id="支持分支"><a href="#支持分支" aria-hidden="true" class="header-anchor">#</a> 支持分支</h2> <p>在主要分支<code>master</code>和旁边<code>develop</code>，我们的开发模型使用各种支持分支来协助团队成员之间的并行开发，简化功能跟踪，为生产发布做准备并协助快速解决生产中的实际问题。与主要分支不同，这些分支的生命周期总是有限的，因为它们最终将被删除。</p> <p>我们可以使用的不同类型的分支机构是：</p> <ul><li>功能分支</li> <li>发布分支</li> <li>修补程序分支</li></ul> <p>这些分支中的每一个都有特定的目的，并受严格的规则约束，即哪些分支可能是其原始分支，哪些分支必须是其合并目标。我们将在一分钟内逐步解决它们。</p> <p>从技术的角度来看，这些分支绝不是“特殊的”。分支类型按我们的<em>使用方式</em>进行分类。它们当然是普通的旧Git分支。</p> <h3 id="功能分支"><a href="#功能分支" aria-hidden="true" class="header-anchor">#</a> 功能分支</h3> <p><img src="https://nvie.com/img/fb@2x.png" alt="img"></p> <ul><li><p>可能从以下分支：</p> <p><code>develop</code></p></li> <li><p>必须合并回：</p> <p><code>develop</code></p></li> <li><p>分支命名约定：</p> <p>任何东西，除了 <code>master</code>，<code>develop</code>，<code>release-*</code>，或者<code>hotfix-*</code></p></li></ul> <p>功能分支（或有时称为主题分支）用于为即将发布或遥远的将来版本开发新功能。当开始开发功能时，此时可能不知道将合并该功能的目标版本。功能分支的本质是只要功能正在开发中就存在，但是最终会合并回去<code>develop</code>（以确保将新功能添加到即将发布的版本中）或丢弃（以防实验失败）。</p> <p>功能分支通常仅存在于开发人员存储库中，而不存在于中<code>origin</code>。</p> <h4 id="创建一个功能分支"><a href="#创建一个功能分支" aria-hidden="true" class="header-anchor">#</a> 创建一个功能分支</h4> <p>开始使用新功能时，请从<code>develop</code>分支分支。</p> <div class="language- extra-class"><pre class="language-text"><code>$ git checkout -b myfeature开发
 切换到新分支“ myfeature”
</code></pre></div><h4 id="在development上包含完成的功能"><a href="#在development上包含完成的功能" aria-hidden="true" class="header-anchor">#</a> 在development上包含完成的功能</h4> <p>可以将完成的功能合并到<code>develop</code>分支中，以确保将它们添加到即将发布的版本中：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git checkout开发
 切换到分支'develop' 
$ git merge --no-ff myfeature
 更新ea1b82a..05e9557 
（更改摘要）
$ git branch -d myfeature
 删除分支myfeature（以前为05e9557）。
$ git push origin development
</code></pre></div><p>该<code>--no-ff</code>标志使合并始终创建一个新的提交对象，即使合并可以通过快进来执行。这样可以避免丢失有关要素分支历史存在的信息，并将所有添加了要素的提交分组在一起。比较：</p> <p><img src="https://nvie.com/img/merge-without-ff@2x.png" alt="img"></p> <p>在后一种情况下，无法从Git历史记录中看到哪些提交对象一起实现了功能—您将不得不手动读取所有日志消息。在后一种情况下，还原整个功能（即一组提交）确实很头疼，而如果使用了<code>--no-ff</code>标志，则很容易做到 。</p> <p>是的，它将创建更多（空）提交对象，但收益远大于成本。</p> <h3 id="发布分支"><a href="#发布分支" aria-hidden="true" class="header-anchor">#</a> 发布分支</h3> <ul><li><p>可能从以下分支：</p> <p><code>develop</code></p></li> <li><p>必须合并回：</p> <p><code>develop</code> 和 <code>master</code></p></li> <li><p>分支命名约定：</p> <p><code>release-*</code></p></li></ul> <p>发布分支支持新产品版本的准备。他们考虑了i的最后一刻和t的交叉。此外，它们还允许进行较小的错误修复并为发布准备元数据（版本号，构建日期等）。通过在发行分支上完成所有这些工作，该<code>develop</code> 分支将被清除以接收下一个大型发行版的功能。</p> <p>从一个新版本分支分支的关键时刻<code>develop</code>是开发（几乎）何时反映了新版本的期望状态。此时至少必须将要构建的发行版的所有目标功能合并到其中 <code>develop</code>。面向将来发行版的所有功能可能都不会—它们必须等到发行分支分支出来之后。</p> <p>正是在发行分支的开头，为即将发布的发行版本分配了一个版本号，而不是更早的版本号。直到那一刻，该<code>develop</code> 分支反映了“下一个发行版”的更改，但是尚不清楚该“下一个发行版”最终将变为0.3还是1.0，直到发行分支开始。该决定是在发布分支的开始处做出的，并由项目的版本号增加规则来执行。</p> <h4 id="创建一个发布分支"><a href="#创建一个发布分支" aria-hidden="true" class="header-anchor">#</a> 创建一个发布分支</h4> <p>从<code>develop</code>分支创建发行分支。例如，说版本1.1.5是当前的生产版本，我们即将发布一个大版本。的状态<code>develop</code>准备好了“下一个版本”，我们已经决定，这将成为版本1.2（而不是1.1.6或2.0）。因此，我们分支并给发行分支起一个反映新版本号的名称：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git checkout -b release-1.2开发
 切换到新的分支“ release-1.2” 
$ ./bump-version.sh 1.2
 文件已成功修改，版本升至1.2。
$ git commit -a -m “将版本号加至1.2” 
[release-1.2 74d9424]将版本号加至1.2 
1个文件已更改，1个插入（+），1个删除（-）
</code></pre></div><p>创建新分支并切换到该分支后，我们更改版本号。这里 <code>bump-version.sh</code>是一个虚构的shell脚本，它更改了工作副本中的某些文件以反映新版本。（当然，这可以是手动更改-关键是<em>有些</em>文件会更改。）然后，提交被修改的版本号。</p> <p>这个新分支可能在那里存在了一段时间，直到可以肯定地发布该版本为止。在此期间，错误修复程序可能会应用于此分支（而不是<code>develop</code>分支）。严格禁止在此处添加大型新功能。它们必须合并到中<code>develop</code>，因此，请等待下一个重要版本。</p> <h4 id="完成发布分支"><a href="#完成发布分支" aria-hidden="true" class="header-anchor">#</a> 完成发布分支</h4> <p>当发布分支的状态准备好成为真实发布时，需要执行一些操作。首先，将release分支合并到其中 <code>master</code>（因为每次提交<code>master</code>都是<em>定义</em>上的新发行版，请记住）。接下来，<code>master</code>必须标记该提交，以方便将来参考此历史版本。最后，需要将对release分支所做的更改重新合并到中<code>develop</code>，以便将来的发行版也包含这些错误修复。</p> <p>Git的前两个步骤：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git checkout master
 切换到分支'master' 
$ git merge --no-ff release-1.2
 递归合并。
（更改摘要）
$ git tag -a 1.2
</code></pre></div><p>该版本现已完成，并已标记以供将来参考。</p> <blockquote><p>**编辑：**您可能还想使用<code>-s</code>或<code>-u</code>标志对您的标签进行加密签名。</p></blockquote> <p>为了保留在release分支中所做的更改，我们需要将这些更改重新合并到中<code>develop</code>。在Git中：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git checkout开发
 切换到分支'develop' 
$ git merge --no-ff release-1.2
 递归合并。
（更改摘要）
</code></pre></div><p>此步骤很可能导致合并冲突（可能甚至发生，因为我们已经更改了版本号）。如果是这样，请修复它并提交。</p> <p>现在我们真的完成了，可以删除发布分支，因为我们不再需要它了：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git branch -d release-1.2
 删除了分支release-1.2（原为ff452fe）。
</code></pre></div><h3 id="修补程序分支"><a href="#修补程序分支" aria-hidden="true" class="header-anchor">#</a> 修补程序分支</h3> <p><img src="https://nvie.com/img/hotfix-branches@2x.png" alt="img"></p> <ul><li><p>可能从以下分支：</p> <p><code>master</code></p></li> <li><p>必须合并回：</p> <p><code>develop</code> 和 <code>master</code></p></li> <li><p>分支命名约定：</p> <p><code>hotfix-*</code></p></li></ul> <p>修补程序分支与发布分支非常相似，尽管它们是计划外的，但它们也旨在为新的生产版本做准备。它们源于必须对不期望的实时生产版本立即采取行动。当必须立即解决生产版本中的严重错误时，可以从标记生产版本的master分支上的相应标记中分支出一个修补程序分支。</p> <p>本质是团队成员（<code>develop</code>分支机构）的工作可以继续，而另一个人正在准备快速的生产修复。</p> <h4 id="创建hotfix分支"><a href="#创建hotfix分支" aria-hidden="true" class="header-anchor">#</a> 创建hotfix分支</h4> <p>修补程序分支是从<code>master</code>分支创建的 。例如，说1.2版是当前生产版本，正在运行，并且由于严重的错误而引起麻烦。但是变化<code>develop</code>仍然不稳定。然后，我们可能会分支出一个修补程序分支并开始解决问题：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git checkout -b hotfix-1.2.1 master
 切换到新分支“ hotfix-1.2.1” 
$ ./bump-version.sh 1.2.1
 文件修改成功，版本升至1.2.1。
$ git commit -a -m “将版本号加至1.2.1” 
[hotfix-1.2.1 41e61bb]将版本号加至1.2.1 
更改了1个文件，1个插入（+），1个删除（-）
</code></pre></div><p>别忘了在分支后增加版本号！</p> <p>然后，修复该错误并在一个或多个单独的提交中提交此修复程序。</p> <div class="language- extra-class"><pre class="language-text"><code>$ git commit -m “修复了严重的生产问题” 
[hotfix-1.2.1 abbe5d6]修复了严重的生产问题
5个文件更改，32个插入（+），17个删除（-）
</code></pre></div><h4 id="完成修补程序分支"><a href="#完成修补程序分支" aria-hidden="true" class="header-anchor">#</a> 完成修补程序分支</h4> <p>完成后，该bugfix需要合并回<code>master</code>，但也需要合并回<code>develop</code>，以确保该bugfix也包含在下一发行版中。这与释放分支的完成方式完全相似。</p> <p>首先，更新<code>master</code>并标记发布。</p> <div class="language- extra-class"><pre class="language-text"><code>$ git checkout master
 切换到分支'master' 
$ git merge --no-ff hotfix-1.2.1
 递归合并。
（更改摘要）
$ git tag -a 1.2.1
</code></pre></div><blockquote><p>**编辑：**您可能还想使用<code>-s</code>或<code>-u</code>标志对您的标签进行加密签名。</p></blockquote> <p>接下来，在<code>develop</code>中也包含错误修正：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git checkout开发
 切换到分支'develop' 
$ git merge --no-ff hotfix-1.2.1
 递归合并。
（更改摘要）
</code></pre></div><p>该规则的一个例外是， <strong>当当前存在发行分支时，需要将修补程序更改而不是合并到该发行分支中<code>develop</code></strong>。在发行分支完成后，将错误修正回合并到发行分支中，最终会导致将修正修正也合并到<code>develop</code>发行分支中。（如果<code>develop</code>立即进行工作需要此错误修正，并且不能等待发行分支完成，则也可以安全地将错误修正合并到<code>develop</code>现在。）</p> <p>最后，删除临时分支：</p> <div class="language- extra-class"><pre class="language-text"><code>$ git branch -d hotfix-1.2.1
 删除了分支hotfix-1.2.1（以前是abbe5d6）。
</code></pre></div><h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2> <p>尽管此分支模型没有什么真正令人震惊的新东西，但本文开头的“全局”图在我们的项目中被证明非常有用。它形成了一个易于理解的优雅思维模型，并使团队成员可以对分支和发布过程形成共识。</p> <p>此处提供了该图的高质量PDF版本。随时将其挂在墙上以随时快速参考。</p> <p>原文：https://nvie.com/posts/a-successful-git-branching-model/</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">3/5/2020, 11:34:17 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/大前端/关于架构.html" class="prev">
          前端架构
        </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.2ae5fea5.js" defer></script><script src="/blog/assets/js/2.6a053b7f.js" defer></script><script src="/blog/assets/js/65.fea30c40.js" defer></script>
  </body>
</html>
